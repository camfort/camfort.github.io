  <section>
  <p>
  CamFort is a multi-feature tool for improving the quality of Fortran
  code. Its features are primarily aimed at programming patterns found
  in numerical modelling code e.g., in computational science.  </p>
  <p>
  CamFort is free and open-source. It currently supports FORTRAN 66,
  FORTRAN 77, and Fortran 90 language standards. Support for Fortran
  95, 2003, and 2008 is in progress.
  </p>
</section>

 <section><span class="title-medium">News / dates</span>
  <p>
<ul id="news">
<li><b>26th July 2017</b> -
     <a href="https://github.com/camfort/camfort/releases/tag/v0.904">
       v0.904 of CamFort has been released
    </a>. The main changes are:
     <ul>
       <li>Better protection against dependencies breaking builds;</li>
       <li>Significantly reduced build time;</li>
       <li>Better command line interface;</li>
       <li>Improved error messages;</li>
       <li>Bug fixes to stencil specifications</li>
     </ul><br>
   </li>
  
  <li><b>24-26th July 2017</b> - We are talking about CamFort at the
  <a
  href="http://www.nag.co.uk/content/fortran-modernization-workshop/barcelona-july-2017">Fortran
  modernization workshop</a>
  at Universitat Politechnica de Catalunya, Barcelona, Spain.
  (<a
  href="http://www.nag.co.uk/content/fortran-modernization-workshop/barcelona-july-2017">details</a>).
  </li><br />
  <li><b>30th May 2017</b> - <a
  href="https://github.com/camfort/camfort/releases/tag/v0.902">
  v0.902 of CamFort has been released</a>. The main changes are:
  <ul><li>Improved stencil specification support;</li>
      <li>Polymorphic unit signatures (see <a
  href="https://github.com/camfort/camfort/blob/master/samples/units/poly1.f90">this
  example</a>);</li>
  <li>Much faster verification times.</li>
  </ul>
  </li>
  </ul>
  </p>
  </section>

  <section> <span class="title-medium">Features</span><br />
  <span class="title-medium-alt">Specification & verification</span>
  <p>
  CamFort provides <em>lightweight verification</em> features. 
  Source-code annotations (comments) provide specifications of certain
  aspects of a program's meaning or behaviour. CamFort can then check
  that code conforms to these specifications. CamFort can also suggest
  places to insert specifications, and in some cases case infer the
  specifications of existing code.</p>
  <p>
  Our current specification and verification features provide:
  <ul>
    <li><b>Units-of-measure typing</b> allows you to annotate Fortran
  source code with units of variables and can automatically check
  whether units are consistently used and report back where it went
    wrong if they are inconsistent.
    Example: <br />
    <div class="code">
      <pre>
  <span class='comment'>!= unit(m) :: d1, d2</span>
  <span class='comment'>!= unit(s) :: t</span>
  <span class='type'>real</span> :: <span class='var'>d1</span>, <span class='var'>d2</span>, <span class='var'>t</span>, <span class='var'>v</span>
  <span class='var'>v</span> = (<span class='var'>d1</span> + <span class='var'>d2</span>)/<span class='var'>t</span>
</pre>
    </div></li>
    <li><b>Array access shape</b>  allows you to describe and verify
  the access patterns your code makes over arrays in order to catch
  array indexing errors. Example: <br />
    <div class="code">
          <pre>
  <span class='keyw'>do</span> <span class='var'>i</span> = 1, <span class='var'>n</span>
    <span class='keyw'>do</span> <span class='var'>j</span> = 1, <span
  class='var'>m</span>
      <span class='var'>x</span> = <span class='var'>a</span>(<span class='var'>i</span>, <span class='var'>j</span>-1) + <span class='var'>a</span>(<span class='var'>i</span>, <span class='var'>j</span>+1) + <span class='var'>a</span>(<span class='var'>i</span>, <span class='var'>j</span>)
      <span class='var'>y</span> = <span class='var'>a</span>(<span class='var'>i</span>+1, <span class='var'>j</span>-1) + <span class='var'>a</span>(<span class='var'>i</span>+1, <span class='var'>j</span>+1) + <span class='var'>a</span>(<span class='var'>i</span>+1, <span class='var'>j</span>)
      <span class='comment'>!= stencil forward(dim=1,depth=1) * centered(dim=2,depth=1) :: a</span>
      <span class='var'>b</span>(<span class='var'>i</span>, <span
  class='var'>j</span>) = <span class='var'>x</span> + <span class='var'>y</span>
    <span class='keyw'>end do</span>
  <span class='keyw'>end do</span>
</pre>
    </div>
    </li>
  </ul>
  </p>
  </section>
  
  <section> <span class="title-medium-alt">Refactoring</span><br />
  <p>
  Many language features of older Fortran standards (pre Fortran 90) are
  known to be a ready source of programming error. CamFort provides
  some facilities for automatically refactoring deprecated or
  dangerous programming patterns, with the goal of helping to meet
  core quality requirements, such as maintainability. For example, our
  tool eliminates EQUIVALENCE and COMMON blocks. These refactorings
  also helps to expose any programming bugs arising from bad
  programming practices.
  </p>
  </section>
  
  <section>
  <span class="title-medium">Long-term
  vision</span><br />
  <p>

  Programming languages provide an interface for developing
  increasingly complex models in science. However, as computer models
  grow more complex, it is increasingly difficult to deliver on core
  requirements such as verifiability, maintainability,
  understandability, validity, and portability.
  
  </p>
  <p>
  
  Managing software complexity more effectively has been a focus of
  programming language research for many years, yet we see little
  adoption of new approaches in the natural sciences. Instead we see
  scientists continually striving to evolve their software to more
  complex models, or bigger data sets or novel execution
  architectures.
  
  </p>
  <p>
  Our objectives are:
  <ul>
    <li>
<b>Crossing the chasm:</b> To show how programming language ideas such as
  inference of high-level programming patterns, advanced types and
  automatic test generation can be used to reduce the accidental
  complexity of real scientific code, and improve its evolution,
    maintainability, and verification.</li>
    <li>
<b>Practical adoption:</b> To develop tools for maintaining and evolving
  established, long-lived code-bases. To apply these ideas without
  disrupting existing practices by accommodating the various
    incarnations of the language, and (custom) pre-processors.</li>
    <li>
<b>Closing the chasm:</b> To provide a framework which makes it easier to
  transfer future programming language research in to practice in
    computational science.
    </li>
  </ul>
  </p>
  </section>